from database.db_manager import DBManager\nfrom utils.logger import logger\nfrom datetime import datetime, timedelta\nfrom sqlalchemy import select\nfrom database.models import Position, Trade\n\nMARK_ORDER_STALE_AFTER = 60 * 60 * 24 * 2 # 2 days\nPEGGED_ORDER_CANCEL_AFTER = 15 # 15 seconds\n\nclass OrderManager:\n    def __init__(self, engine, brokers):\n        logger.info('Initializing OrderManager')\n        self.engine = engine\n        self.db_manager = DBManager(engine)\n        self.brokers = brokers\n\n    async def reconcile_orders(self, orders):\n        logger.info('Reconciling orders', extra={'orders': orders})\n        for order in orders:\n            await self.reconcile_order(order)\n        # Commit the transaction\n\n    async def reconcile_order(self, order):\n        logger.info(f'Reconciling order {order.id}', extra={'order_id': order.id, 'broker_id': order.broker_id, 'broker': order.broker, 'symbol': order.symbol, 'quantity': order.quantity, 'price': order.price, 'side': order.side, 'status': order.status})\n\n        # Calculate the stale threshold\n        stale_threshold = datetime.utcnow() - timedelta(seconds=MARK_ORDER_STALE_AFTER)\n\n        # Check if the order is stale\n        if order.timestamp < stale_threshold and order.status not in ['filled', 'cancelled']: \n            try:\n                logger.info(f'Marking order {order.id} as stale', extra={'order_id': order.id})\n                await self.db_manager.update_trade_status(order.id, 'stale')\n                return  # Exit early if the order is stale\n            except Exception as e:\n                logger.error(f'Error marking order {order.id} as stale', extra={'error': str(e)})\n                return\n\n        # If the order is not stale, reconcile it\n        broker = self.brokers[order.broker]\n        if order.broker_id is None:\n            # If the order has no broker_id, mark it as stale\n            logger.info(f'Marking order {order.id} as stale, missing broker_id', extra={'order_id': order.id})\n            await self.db_manager.update_trade_status(order.id, 'stale')\n            return\n        filled = await broker.is_order_filled(order.broker_id)\n        if filled:\n            try:\n                async with self.db_manager.Session() as session:\n                    await self.db_manager.set_trade_filled(order.id)\n                    await broker.update_positions(order.id, session)\n            except Exception as e:\n                logger.error(f'Error reconciling order {order.id}', extra={'error': str(e)})\n                return\n\n        elif order.execution_style == 'pegged':\n            cancel_threshold = datetime.utcnow() - timedelta(seconds=PEGGED_ORDER_CANCEL_AFTER)\n            if order.timestamp < cancel_threshold:\n                try:\n                    logger.info(f'Cancelling pegged order {order.id}', extra={'order_id': order.id})\n                    await broker.cancel_order(order.broker_id)\n                    await self.db_manager.update_trade_status(order.id, 'cancelled')\n                    mid_price = await broker.get_mid_price(order.symbol)\n                    await self.place_order(\n                        order.symbol, order.quantity, order.side, order.strategy_name, round(mid_price, 2), order_type='limit', execution_style=order.execution_style\n                    )\n                except Exception as e:\n                    logger.error(f'Error cancelling pegged order {order.id}', extra={'error': str(e)})\n                    return\n\n    async def run(self):\n        logger.info('Running OrderManager')\n        orders = await self.db_manager.get_open_trades()\n        await self.reconcile_orders(orders)\n\nasync def run_order_manager(engine, brokers):\n    order_manager = OrderManager(engine, brokers)\n    await order_manager.run()