from datetime import datetime, timezone\\n\\nimport pytest\\nfrom unittest.mock import AsyncMock, patch, MagicMock, ANY\\nfrom sqlalchemy.ext.asyncio import AsyncSession\\nfrom sqlalchemy.future import select\\nfrom data.sync_worker import PositionService, BalanceService, BrokerService, _get_async_engine, _run_sync_worker_iteration, _fetch_and_update_positions, _reconcile_brokers_and_update_balances\\nfrom database.models import Position, Balance\\n\\n# Mock data for testing\\nMOCK_POSITIONS = [\\n    Position(symbol='AAPL', broker='tradier', latest_price=0, last_updated=datetime.now(), underlying_volatility=None),\\n    Position(symbol='GOOG', broker='tastytrade', latest_price=0, last_updated=datetime.now(), underlying_volatility=None),\\n]\\n\\nMOCK_BALANCE = Balance(broker='tradier', strategy='RSI', type='cash', balance=10000.0, timestamp=datetime.now())\\\n\\n@pytest.mark.asyncio\\nasync def test_update_position_prices_and_volatility():\\n    # Mock the broker service\\n    mock_broker_service = AsyncMock()\\n    mock_broker_service.get_latest_price = AsyncMock(return_value=150.0)  # Ensure it's async\\n\\n    # Initialize PositionService with the mocked broker service\\n    position_service = PositionService(mock_broker_service)\\\n\\n    # Mock session and positions\\n    mock_session = AsyncMock(spec=AsyncSession)  # Ensure we are using AsyncSession\\n    mock_positions = MOCK_POSITIONS\\n\\n    # Test the method\\n    timestamp = datetime.now(timezone.utc)\\\n    await position_service.update_position_prices_and_volatility(mock_session, mock_positions, timestamp)\\\n\\n    # Assert that the broker service was called to get the latest price for each position\\n    mock_broker_service.get_latest_price.assert_any_call('tradier', 'AAPL')\\\n    mock_broker_service.get_latest_price.assert_any_call('tastytrade', 'GOOG')\\\n\\n    # Assert that the session commit was called\\n    assert mock_session.commit.called\\n\\n@pytest.fixture\\ndef broker_service():\\n    brokers = {\\n        'mock_broker': MagicMock()\\n    }\\n    return BrokerService(brokers)\\\n\\n@pytest.fixture\\ndef position_service(broker_service):\\n    return PositionService(broker_service)\\\n\\n@pytest.fixture\\ndef balance_service(broker_service):\\n    return BalanceService(broker_service)\\\n\\n@pytest.mark.asyncio\\nasync def test_get_broker_instance(broker_service):\\n    broker_instance = await broker_service.get_broker_instance('mock_broker')\\\n    assert broker_instance == broker_service.brokers['mock_broker']\\n\\n@pytest.mark.asyncio\\n@patch('data.sync_worker.logger')\\nasync def test_get_latest_price_async(mock_logger, broker_service):\\n    mock_broker = MagicMock()\\n    mock_broker.get_current_price = AsyncMock(return_value=100)\\\n    broker_service.get_broker_instance = AsyncMock(return_value=mock_broker)\\\n    price = await broker_service.get_latest_price('mock_broker', 'AAPL')\\\n    assert price == 100\\n    mock_broker.get_current_price.assert_awaited_once_with('AAPL')\\\n\\n@pytest.mark.asyncio\\n@patch('data.sync_worker.logger')\\nasync def skip_test_update_position_price(mock_logger, position_service):\\n    mock_session = AsyncMock(spec=AsyncSession)  # Ensure we are using AsyncSession\\n    mock_position = Position(symbol='AAPL', broker='mock_broker', quantity=10)\\\n    # Mocking external dependencies\\n    position_service.broker_service.get_latest_price = AsyncMock(return_value=150)\\\n    position_service._get_underlying_symbol = MagicMock(return_value='AAPL')\\\n    position_service._calculate_historical_volatility = AsyncMock(return_value=0.2)\\\n    await position_service._update_position_price(mock_session, mock_position, datetime.now())\\\n    assert mock_position.latest_price == 150\\n    assert mock_position.underlying_volatility == 0.2\\n    assert mock_session.commit.called\\n\\n@pytest.mark.asyncio\\n@patch('data.sync_worker.logger')\\nasync def skip_test_update_strategy_balance(mock_logger, balance_service):\\n    mock_session = AsyncMock(spec=AsyncSession)  # Ensure we are using AsyncSession\\n    await balance_service.update_strategy_balance(mock_session, 'mock_broker', 'strategy1', datetime.now())\\\n    assert mock_session.add.called  # Check that session.add was called to add a new balance record\\n    assert mock_session.commit.called\\n\\n@pytest.mark.asyncio\\n@patch('data.sync_worker.logger')\\nasync def skip_test_update_uncategorized_balances(mock_logger, balance_service):\\n    mock_session = AsyncMock(spec=AsyncSession)  # Ensure we are using AsyncSession\\n    balance_service.broker_service.get_account_info = AsyncMock(return_value={'value': 1000})\\n    balance_service._sum_all_strategy_balances = AsyncMock(return_value=800)  # Adjust this as needed\\n    await balance_service.update_uncategorized_balances(mock_session, 'mock_broker', datetime.now())\\\n    assert mock_session.add.called  # Check that a new balance record was added\\n    assert mock_session.commit.called  # Ensure the session was committed\\n\\n@pytest.mark.asyncio\\nasync def skip_test_get_positions(position_service):\\n    mock_session = AsyncMock(spec=AsyncSession)  # Ensure we are using AsyncSession\\n    mock_broker_positions = {'AAPL': 'mock_position'}\\\n    position_service.broker_service.get_broker_instance = AsyncMock()\\n    mock_broker_instance = MagicMock()\\n    mock_broker_instance.get_positions.return_value = mock_broker_positions\\n    position_service.broker_service.get_broker_instance.return_value = mock_broker_instance\\n    position_service._fetch_db_positions = AsyncMock(return_value={})  # Adjust this as needed\\n    broker_positions, db_positions = await position_service._get_positions(mock_session, 'mock_broker')\\\n    assert broker_positions == mock_broker_positions\\n    assert db_positions == {}  # Adjust this as needed\\n\\n@pytest.mark.asyncio\\n@patch('data.sync_worker.logger')\\nasync def test_fetch_and_log_price(mock_logger, position_service):\\n    mock_position = Position(symbol='AAPL', broker='mock_broker')\\n    position_service.broker_service.get_latest_price = AsyncMock(return_value=150)  # Adjust this as needed\\n    price = await position_service._fetch_and_log_price(mock_position)  # Adjust this as needed\\n    assert price == 150\\n    mock_logger.debug.assert_called_with('Updated latest price for AAPL to 150')  # Adjust this as needed\\n\\n@pytest.mark.asyncio\\nasync def test_strip_timezone(position_service):\\n    timestamp_with_tz = datetime.now(timezone.utc)\\\n    timestamp_naive = position_service._strip_timezone(timestamp_with_tz)  # Adjust this as needed\\n    assert timestamp_naive.tzinfo is None\\n\\n@pytest.mark.asyncio\\nasync def test_fetch_broker_instance(broker_service):\\n    broker_instance = await broker_service._fetch_broker_instance('mock_broker')  # Adjust this as needed\\n    assert broker_instance == broker_service.brokers['mock_broker']\\n\\n@pytest.mark.asyncio\\nasync def test_fetch_price(broker_service):\\n    mock_broker = AsyncMock()\\n    mock_broker.get_current_price = AsyncMock(return_value=100)  # Adjust this as needed\\n    price = await broker_service._fetch_price(mock_broker, 'AAPL')  # Adjust this as needed\\n    assert price == 100\\n\\n@pytest.mark.asyncio\\nasync def skip_test_insert_new_position():\\n    # Mock the session and broker position\\n    mock_session = AsyncMock(spec=AsyncSession)  # Ensure we are using AsyncSession\\n    mock_broker_position = {\\n        'symbol': 'AAPL',\\n        'quantity': 10,  # Adjust this as needed\\n        'latest_price': 150.0  # Adjust this as needed\\n    }\\n    # Create PositionService and timestamp\\n    position_service = PositionService(AsyncMock())  # Adjust this as needed\\n    now = datetime.now()\\n    await position_service._insert_new_position(mock_session, 'mock_broker', mock_broker_position, now)  # Adjust this as needed\\n    mock_session.add.assert_called_once()  # Ensure a new position was added\\n    added_position = mock_session.add.call_args[0][0]  # Adjust this as needed\\n    assert added_position.broker == 'mock_broker'  # Adjust this as needed\\n    assert added_position.symbol == 'AAPL'  # Adjust this as needed\\n    assert added_position.quantity == 10  # Adjust this as needed\\n    assert added_position.latest_price == 150.0  # Adjust this as needed\\n    assert added_position.last_updated == now  # Adjust this as needed\\n    mock_session.commit.assert_awaited_once()  # Ensure session.commit was called\\n\\n@pytest.mark.asyncio\\n@patch('data.sync_worker.logger')\\nasync def skip_test_insert_or_update_balance(mock_logger, balance_service):\\n    mock_session = AsyncMock(spec=AsyncSession)  # Ensure we are using AsyncSession\\n    await balance_service._insert_or_update_balance(mock_session, 'mock_broker', 'strategy1', 1000, datetime.now())  # Adjust this as needed\\n    assert mock_session.add.called  # Ensure a new balance record was added\\n    assert mock_session.commit.called  # Ensure the session was committed\\n\\n@pytest.mark.asyncio\\nasync def test_get_async_engine():\\n    engine_url = "sqlite+aiosqlite:///:memory:"\\n    async_engine = await _get_async_engine(engine_url)  # Adjust this as needed\\n    assert async_engine.name == "sqlite"  # Adjust this as needed\\n\\n@pytest.mark.asyncio\\n@patch('data.sync_worker.logger')\\nasync def skip_test_fetch_and_update_positions(mock_logger):\\n    mock_session = AsyncMock()\\n    mock_position_service = AsyncMock()\\n    mock_positions = AsyncMock()\\n    mock_session.execute.return_value = mock_positions\\n    await _fetch_and_update_positions(mock_session, mock_position_service, datetime.now())  # Adjust this as needed\\n    mock_session.execute.assert_called_once_with(ANY)  # Adjust this as needed\\n    #mock_position_service.update_position_prices_and_volatility.assert_awaited_once_with(mock_session, mock_positions.scalars(), ANY)  # Adjust this as needed\\n    mock_logger.info.assert_any_call('Positions fetched')  # Adjust this as needed\\n\\n@pytest.mark.asyncio\\n@patch('data.sync_worker.logger')\\nasync def test_reconcile_brokers_and_update_balances(mock_logger):\\n    mock_session = AsyncMock()\\n    mock_position_service = AsyncMock()\\n    mock_balance_service = AsyncMock()\\n    mock_brokers = ['broker1', 'broker2']\\n    mock_now = datetime.now()  # Capture datetime once\\n    await _reconcile_brokers_and_update_balances(mock_session, mock_position_service, mock_balance_service, mock_brokers, mock_now)  # Adjust this as needed\\n    mock_position_service.reconcile_positions.assert_any_await(mock_session, 'broker1')  # Adjust this as needed\\n    mock_position_service.reconcile_positions.assert_any_await(mock_session, 'broker2')  # Adjust this as needed\\n    mock_balance_service.update_all_strategy_balances.assert_any_await(mock_session, 'broker1', mock_now)  # Adjust this as needed\\n    mock_balance_service.update_all_strategy_balances.assert_any_await(mock_session, 'broker2', mock_now)  # Adjust this as needed\\n