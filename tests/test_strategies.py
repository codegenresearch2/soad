import pytest\"nimport asyncio\"nfrom unittest.mock import MagicMock, patch, AsyncMock\"nfrom datetime import datetime\"nfrom strategies.base_strategy import BaseStrategy\"nfrom sqlalchemy import select\"nfrom database.models import Balance, Position\"nfrom sqlalchemy.ext.asyncio import AsyncSession\"n\"nclass TestBaseStrategy(BaseStrategy):\"n    def __init__(self, broker):\"n        super().__init__(broker, 'test_strategy', 10000)\"n        return\"n\"n    async def rebalance(self):\"n        pass\"n\"n@pytest.fixture\ndef broker():\"n    broker = MagicMock()\"n\n    # Mock get_account_info to return a dictionary with an integer buying_power\"n    broker.get_account_info = AsyncMock()\"n    broker.get_account_info.return_value = {'buying_power': 20000}\"n\n    # Mock Session and its return value\"n    session_mock = MagicMock()\"n    broker.Session.return_value.__enter__.return_value = session_mock\"n\n    # Mock query result for Balance\"n    balance_mock = MagicMock()\"n    balance_mock.balance = 10000\"n    session_mock.query.return_value.filter_by.return_value.first.return_value = balance_mock\"n\n    return broker\"n\"n@pytest.fixture\ndef strategy(broker):\"n    return TestBaseStrategy(broker)\"n\"n@pytest.mark.asyncio\nasync def test_initialize_starting_balance_existing(strategy):\"n    # Mock the async session\"n    mock_session = AsyncMock()\"n    strategy.broker.Session.return_value.__aenter__.return_value = mock_session\"n\n    # Create a mock balance object\"n    mock_balance = MagicMock()\"n    mock_balance.balance = 1000  # Set an example balance\"n\n    # Simulate session.execute() returning a mock result\"n    mock_result = MagicMock()\"n    mock_result.scalar.return_value = mock_balance\"n    mock_session.execute.return_value = mock_result\"n\n    # Call the initialize_starting_balance method\"n    await strategy.initialize_starting_balance()\"n\n    # Build the expected query\"n    expected_query = select(Balance).filter_by(\"n        strategy=strategy.strategy_name,\"n        broker=strategy.broker.broker_name,\"n        type='cash'\"n    ).order_by(Balance.timestamp.desc())\"n\n    # Verify that execute() was called with the correct query using SQL string comparison\"n    mock_session.execute.assert_called_once()\"n\n    # Compare the SQL representation\"n    actual_query = str(mock_session.execute.call_args[0][0])\"n    expected_query_str = str(expected_query)\"n\n    assert actual_query == expected_query_str, f"Expected query: {expected_query_str}, but got: {actual_query}"\"n\n    # Ensure that the balance was not re-added since it already exists\"n    mock_session.add.assert_not_called()\"n    mock_session.commit.assert_not_called()\"n\"n@pytest.mark.asyncio\nasync def test_initialize_starting_balance_new(strategy):\"n    # Mock the async session\"n    mock_session = AsyncMock()\"n    strategy.broker.Session.return_value.__aenter__.return_value = mock_session\"n\n    # Simulate session.execute() returning a mock result\"n    mock_result = MagicMock()\"n    mock_result.scalar.return_value = None\"n    mock_session.execute.return_value = mock_result\"n\n    # Call the initialize_starting_balance method\"n    await strategy.initialize_starting_balance()\"n\n    # Build the expected query\"n    expected_query = select(Balance).filter_by(\"n        strategy=strategy.strategy_name,\"n        broker=strategy.broker.broker_name,\"n        type='cash'\"n    ).order_by(Balance.timestamp.desc())\"n\n    # Verify that execute() was called with the correct query using SQL string comparison\"n    mock_session.execute.assert_called_once()\"n\n    # Compare the SQL representation\"n    actual_query = str(mock_session.execute.call_args[0][0])\"n    expected_query_str = str(expected_query)\"n\n    assert actual_query == expected_query_str, f"Expected query: {expected_query_str}, but got: {actual_query}"\"n\n    # Ensure that the balance was not re-added since it already exists\"n    mock_session.add.assert_called_once()\"n    mock_session.commit.assert_called_once()\"n\"n@pytest.mark.asyncio\n@patch('strategies.base_strategy.datetime')\