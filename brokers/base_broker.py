from abc import ABC, abstractmethod\\nimport asyncio\\nfrom sqlalchemy.ext.asyncio import AsyncSession\\nfrom sqlalchemy import select\\nfrom database.db_manager import DBManager\\nfrom database.models import Trade, AccountInfo, Position, Balance\\nfrom utils.logger import logger\\nfrom utils.utils import futures_contract_size\\n\\n# Define a constant for options contract size\\nOPTIONS_CONTRACT_SIZE = 100\\n\\nclass BaseBroker(ABC):\\n    def __init__(self, api_key, secret_key, broker_name, engine, prevent_day_trading=False):\\n        self.api_key = api_key\\n        self.secret_key = secret_key\\n        self.broker_name = broker_name.lower()\\n        self.db_manager = DBManager(engine) \\n        # Use AsyncSession\\n        self.Session = asyncio.get_event_loop().run_until_complete(asyncio.create_task(sessionmaker(bind=engine, class_=AsyncSession, expire_on_commit=True))) \\n        self.account_id = None\\n        self.prevent_day_trading = prevent_day_trading\\n        logger.info('Initialized BaseBroker', extra={'broker_name': self.broker_name})\\n\\n    @abstractmethod\\n    def connect(self):\\n        pass\\n\\n    @abstractmethod\\n    def _get_account_info(self):\\n        pass\\n\\n    @abstractmethod\\n    def _place_order(self, symbol, quantity, order_type, price=None):\\n        pass\\n\\n    @abstractmethod\\n    def _place_future_option_order(self, symbol, quantity, order_type, price=None):\\n        pass\\n\\n    @abstractmethod\\n    def _place_option_order(self, symbol, quantity, order_type, price=None):\\n        pass\\n\\n    @abstractmethod\\n    def _get_order_status(self, order_id):\\n        pass\\n\\n    @abstractmethod\\n    def _cancel_order(self, order_id):\\n        pass\\n\\n    @abstractmethod\\n    def _get_options_chain(self, symbol, expiration_date):\\n        pass\\n\\n    @abstractmethod\\n    def get_current_price(self, symbol):\\n        pass\\n\\n    @abstractmethod\\n    def get_positions(self):\\n        pass\\n\\n    async def get_account_info(self):\\n        logger.info('Getting account information')\\n        try:\\n            account_info = self._get_account_info()\\n            await self.db_manager.add_account_info(AccountInfo(\n                broker=self.broker_name, value=account_info['value']\n            ))\\n            logger.info('Account information retrieved', extra={'account_info': account_info})\\n            return account_info\\n        except Exception as e:\\n            logger.error('Failed to get account information', extra={'error': str(e)})\\n            return None\\n\\n    async def has_bought_today(self, symbol):\\n        today = datetime.now().date()\\n        logger.info('Checking if bought today', extra={'symbol': symbol})\\n        try:\\n            async with self.Session() as session:\\n                result = await session.execute(select(Trade).\\n                    filter_by(symbol=symbol, broker=self.broker_name, order_type='buy').\\n                    filter(Trade.timestamp >= today))\\n                trade = result.scalars().first()\\n                return trade is not None\\n        except Exception as e:\\n            logger.error('Failed to check if bought today', extra={'error': str(e)})\\n            return False\\n\\n    async def update_positions(self, trade):\\n        logger.info('Updating positions', extra={'trade': trade})\\n        if trade.quantity == 0:\\n            logger.error('Trade quantity is 0, doing nothing', extra={'trade': trade})\\n            return\\n        try:\\n            async with self.Session() as session:\\n                result = await session.execute(select(Position).filter_by(\n                    symbol=trade.symbol, broker=self.broker_name, strategy=trade.strategy\n                ))\\n                position = result.scalars().first()\\n                if trade.order_type == 'buy':\\n                    logger.info('Processing buy order', extra={'trade': trade})\\n                    if position:\\n                        logger.debug(f"Updating existing position: {position}")\\n                        position.cost_basis += trade.executed_price * trade.quantity\\n                        position.quantity += trade.quantity\\n                        position.latest_price = trade.executed_price\\n                        position.timestamp = datetime.now()\\n                    else:\\n                        logger.debug(f"Creating new position for symbol: {trade.symbol}")\\n                        position = Position(\n                            broker=self.broker_name,\n                            strategy=trade.strategy,\n                            symbol=trade.symbol,\n                            quantity=trade.quantity,\n                            latest_price=trade.executed_price,\n                            cost_basis=trade.executed_price * trade.quantity,\n                        )\n                        session.add(position) \\n                elif trade.order_type == 'sell':\\n                    logger.info('Processing sell order', extra={'trade': trade})\\n                    if position:\\n                        if position.quantity == trade.quantity:\\n                            logger.info('Deleting sold position', extra={'position': position})\\n                            await session.delete(position) \\n                            await session.commit()\\n                        elif position.quantity > trade.quantity:\\n                            logger.debug(f"Reducing quantity of position: {position}")\\n                            cost_per_share = position.cost_basis / position.quantity\\n                            position.cost_basis -= trade.quantity * cost_per_share\\n                            position.quantity -= trade.quantity\\n                            position.latest_price = trade.executed_price\\n                        session.add(position) \\n                await session.commit()\\n                logger.info('Position updated', extra={'position': position})\\n        except Exception as e:\\n            logger.error('Failed to update positions', extra={'error': str(e)})\\n\\n    async def place_future_option_order(self, symbol, quantity, order_type, strategy, price=None):\\n        if asyncio.iscoroutinefunction(self._place_future_option_order):\\n            response = await self._place_future_option_order(symbol, quantity, order_type, price) \\n        else:\\n            response = self._place_future_option_order(symbol, quantity, order_type, price) \\n        logger.info('Order placed successfully', extra={'response': response})\\n        if not price:\\n            price = getattr(getattr(response, 'order', None), 'price', None) \\n        if price is None:\\n            logger.error('Price not found in response, not tracking this trade', extra={'response': response})\\n        trade = Trade(\n            symbol=symbol,\n            quantity=quantity,\n            price=price,\n            executed_price=price,\n            order_type=order_type,\n            status='filled',\n            timestamp=datetime.now(),\n            broker=self.broker_name,\n            strategy=strategy,\n            profit_loss=0,\n            success='yes'\n        )\n        if order_type == 'sell':\\n            profit_loss = self.db_manager.calculate_profit_loss(trade) \\n            logger.info('Profit/Loss calculated', extra={'profit_loss': profit_loss})\\n            trade.profit_loss = profit_loss\\n        async with self.Session() as session:\\n            session.add(trade) \\n            await session.commit()\\n            await self.update_positions(trade) \\n            latest_balance = await session.execute(select(Balance).filter_by(\n                broker=self.broker_name, strategy=strategy, type='cash'\n            ).order_by(Balance.timestamp.desc()))\\n            latest_balance = latest_balance.scalars().first()\\n            if latest_balance:\\n                multiplier = futures_contract_size(symbol) \\n                if multiplier == 1:\\n                    logger.error(f'Contract {symbol} not supported. Invalid symbol for future option.', extra={'symbol': symbol})\\n                    return None\\n                order_cost = trade.executed_price * quantity * multiplier\\n                new_balance_amount = latest_balance.balance - order_cost if order_type == 'buy' else latest_balance.balance + order_cost\\n                new_balance = Balance(\n                    broker=self.broker_name,\n                    strategy=strategy,\n                    type='cash',\n                    balance=new_balance_amount,\n                    timestamp=datetime.now()\n                )\n                session.add(new_balance) \\n                await session.commit()\\n        return response\\n\\n    async def place_option_order(self, symbol, quantity, order_type, strategy, price=None):\\n        if asyncio.iscoroutinefunction(self._place_option_order):\\n            response = await self._place_option_order(symbol, quantity, order_type, price) \\n        else:\\n            response = self._place_option_order(symbol, quantity, order_type, price) \\n        logger.info('Order placed successfully', extra={'response': response})\\n        if not price:\\n            price = response.get('filled_price', None) \\n        trade = Trade(\n            symbol=symbol,\n            quantity=quantity,\n            price=price,\n            executed_price=price,\n            order_type=order_type,\n            status='filled',\n            timestamp=datetime.now(),\n            broker=self.broker_name,\n            strategy=strategy,\n            profit_loss=0,\n            success='yes'\n        )\n        if order_type == 'sell':\\n            profit_loss = self.db_manager.calculate_profit_loss(trade) \\n            logger.info('Profit/Loss calculated', extra={'profit_loss': profit_loss})\\n            trade.profit_loss = profit_loss\\n        async with self.Session() as session:\\n            session.add(trade) \\n            await session.commit()\\n            await self.update_positions(trade) \\n            latest_balance = await session.execute(select(Balance).filter_by(\n                broker=self.broker_name, strategy=strategy, type='cash'\n            ).order_by(Balance.timestamp.desc()))\\n            latest_balance = latest_balance.scalars().first()\\n            if latest_balance:\\n                order_cost = trade.executed_price * quantity * OPTIONS_CONTRACT_SIZE\\n                new_balance_amount = latest_balance.balance - order_cost if order_type == 'buy' else latest_balance.balance + order_cost\\n                new_balance = Balance(\n                    broker=self.broker_name,\n                    strategy=strategy,\n                    type='cash',\n                    balance=new_balance_amount,\n                    timestamp=datetime.now()\n                )\n                session.add(new_balance) \\n                await session.commit()\\n        return response\\n\\n    async def place_order(self, symbol, quantity, order_type, strategy, price=None):\\n        if asyncio.iscoroutinefunction(self._place_order):\\n            response = await self._place_order(symbol, quantity, order_type, price) \\n        else:\\n            response = self._place_order(symbol, quantity, order_type, price) \\n        logger.info('Order placed successfully', extra={'response': response})\\n        if not price:\\n            price = response.get('filled_price', None) \\n        trade = Trade(\n            symbol=symbol,\n            quantity=quantity,\n            price=price,\n            executed_price=price,\n            order_type=order_type,\n            status='filled',\n            timestamp=datetime.now(),\n            broker=self.broker_name,\n            strategy=strategy,\n            profit_loss=0,\n            success='yes'\n        )\n        if order_type == 'sell':\\n            profit_loss = self.db_manager.calculate_profit_loss(trade) \\n            logger.info('Profit/Loss calculated', extra={'profit_loss': profit_loss})\\n            trade.profit_loss = profit_loss\\n        async with self.Session() as session:\\n            session.add(trade) \\n            await session.commit()\\n            await self.update_positions(trade) \\n            latest_balance = await session.execute(select(Balance).filter_by(\n                broker=self.broker_name, strategy=strategy, type='cash'\n            ).order_by(Balance.timestamp.desc()))\\n            latest_balance = latest_balance.scalars().first()\\n            if latest_balance:\\n                order_cost = trade.executed_price * quantity\\n                new_balance_amount = latest_balance.balance - order_cost if order_type == 'buy' else latest_balance.balance + order_cost\\n                new_balance = Balance(\n                    broker=self.broker_name,\n                    strategy=strategy,\n                    type='cash',\n                    balance=new_balance_amount,\n                    timestamp=datetime.now()\n                )\n                session.add(new_balance) \\n                await session.commit()\\n        return response\\n\\n    async def get_order_status(self, order_id):\\n        logger.info('Retrieving order status', extra={'order_id': order_id})\\n        try:\\n            order_status = self._get_order_status(order_id) \\n            async with self.Session() as session:\\n                trade = await session.execute(session.query(Trade).filter_by(id=order_id))\\n                trade = trade.scalars().first()\\n                if trade:\\n                    await self.update_trade(session, trade.id, order_status) \\n            logger.info('Order status retrieved', extra={'order_status': order_status})\\n            return order_status\\n        except Exception as e:\\n            logger.error('Failed to get order status', extra={'error': str(e)})\\n            return None\\n\\n    async def cancel_order(self, order_id):\\n        logger.info('Cancelling order', extra={'order_id': order_id})\\n        try:\\n            cancel_status = self._cancel_order(order_id) \\n            async with self.Session() as session:\\n                trade = await session.execute(session.query(Trade).filter_by(id=order_id))\\n                trade = trade.scalars().first()\\n                if trade:\\n                    await self.update_trade(session, trade.id, cancel_status) \\n            logger.info('Order cancelled successfully', extra={'cancel_status': cancel_status})\\n            return cancel_status\\n        except Exception as e:\\n            logger.error('Failed to cancel order', extra={'error': str(e)})\\n            return None\\n\\n    def position_exists(self, symbol):\\n        positions = self.get_positions()\\n        return symbol in positions\\n\\n    def get_options_chain(self, symbol, expiration_date):\\n        logger.info('Retrieving options chain', extra={'symbol': symbol, 'expiration_date': expiration_date})\\n        try:\\n            options_chain = self._get_options_chain(symbol, expiration_date) \\n            logger.info('Options chain retrieved', extra={'options_chain': options_chain})\\n            return options_chain\\n        except Exception as e:\\n            logger.error('Failed to retrieve options chain', extra={'error': str(e)})\\n            return None\\n\\n    async def update_trade(self, session, trade_id, order_info):\\n        try:\\n            trade = await session.execute(session.query(Trade).filter_by(id=trade_id))\\n            trade = trade.scalars().first()\\n            if not trade:\\n                logger.error('Trade not found for update', extra={'trade_id': trade_id})\\n                return\\n            executed_price = order_info.get('filled_price', trade.price) \\n            trade.executed_price = executed_price\\n            profit_loss = self.db_manager.calculate_profit_loss(trade) \\n            success = "success" if profit_loss > 0 else "failure"\\n            trade.executed_price = executed_price\\n            trade.success = success\\n            trade.profit_loss = profit_loss\\n            await session.commit()\\n            logger.info('Trade updated', extra={'trade': trade})\\n        except Exception as e:\\n            logger.error('Failed to update trade', extra={'error': str(e)})\\n