from abc import ABC, abstractmethod\\nimport asyncio\\nfrom sqlalchemy.ext.asyncio import AsyncSession\\nfrom sqlalchemy import select\\nfrom database.models import Balance, Position\\nfrom utils.logger import logger\\nfrom utils.utils import is_market_open, is_futures_symbol, is_futures_market_open\\n\\nclass BaseBroker(ABC):\\n    def __init__(self, api_key, secret_key, broker_name, engine, prevent_day_trading=False):\\n        self.api_key = api_key\\n        self.secret_key = secret_key\\n        self.broker_name = broker_name.lower()\\n        self.engine = engine\\n        self.prevent_day_trading = prevent_day_trading\\n        self.Session = asyncio.create_task(self.create_session())\\n        logger.info('Initialized BaseBroker', extra={'broker_name': self.broker_name})\\n\\n    async def create_session(self):\\n        return sessionmaker(bind=self.engine, class_=AsyncSession, expire_on_commit=False)\\n\\n    @abstractmethod\\n    def connect(self):\\n        pass\\n\\n    @abstractmethod\\n    def _get_account_info(self):\\n        pass\\n\\n    @abstractmethod\\n    def _place_order(self, symbol, quantity, order_type, price=None):\\n        pass\\n\\n    @abstractmethod\\n    def _place_future_option_order(self, symbol, quantity, order_type, price=None):\\n        pass\\n\\n    @abstractmethod\\n    def _place_option_order(self, symbol, quantity, order_type, price=None):\\n        pass\\n\\n    @abstractmethod\\n    def _get_order_status(self, order_id):\\n        pass\\n\\n    @abstractmethod\\n    def _cancel_order(self, order_id):\\n        pass\\n\\n    @abstractmethod\\n    def _get_options_chain(self, symbol, expiration_date):\\n        pass\\n\\n    @abstractmethod\\n    def get_current_price(self, symbol):\\n        pass\\n\\n    @abstractmethod\\n    def get_positions(self):\\n        pass\\n\\n    async def get_account_info(self):\\n        logger.info('Getting account information')\\n        try:\\n            account_info = self._get_account_info()\\n            async with self.Session() as session:\\n                await session.execute(select(Balance).filter_by(strategy=self.strategy_name, broker=self.broker_name, type='cash'))\\n            logger.info('Account information retrieved', extra={'account_info': account_info})\\n            return account_info\\n        except Exception as e:\\n            logger.error('Failed to get account information', extra={'error': str(e)})\\n            return None\\n\\n    async def has_bought_today(self, symbol):\\n        try:\\n            today = datetime.now().date()\\n            async with self.Session() as session:\\n                result = await session.execute(select(Trade).filter_by(symbol=symbol, broker=self.broker_name, order_type='buy').filter(Trade.timestamp >= today))\\n            trade = result.scalars().first()\\n            return trade is not None\\n        except Exception as e:\\n            logger.error('Failed to check if bought today', extra={'error': str(e)})\\n            return False\\n\\n    async def place_future_option_order(self, symbol, quantity, order_type, strategy, price=None):\\n        logger.info('Placing order', extra={'symbol': symbol, 'quantity': quantity, 'order_type': order_type, 'strategy': strategy})\\n        try:\\n            response = self._place_future_option_order(symbol, quantity, order_type, price)\\n            logger.info('Order placed successfully', extra={'response': response})\\n            if not price:\\n                price = getattr(getattr(response, 'order', None), 'price', None)\\n            trade = Trade(symbol=symbol, quantity=quantity, price=price, executed_price=price, order_type=order_type, status='filled', timestamp=datetime.now(), broker=self.broker_name, strategy=strategy, profit_loss=0, success='yes')\\n            if order_type == 'sell':\\n                profit_loss = self.db_manager.calculate_profit_loss(trade)\\n                logger.info('Profit/Loss calculated', extra={'profit_loss': profit_loss})\\n                trade.profit_loss = profit_loss\\n            async with self.Session() as session:\\n                session.add(trade)\\n                await session.commit()\\n            return response\\n        except Exception as e:\\n            logger.error('Failed to place order', extra={'error': str(e)})\\n            return None\\n\\n    async def place_option_order(self, symbol, quantity, order_type, strategy, price=None):\\n        logger.info('Placing order', extra={'symbol': symbol, 'quantity': quantity, 'order_type': order_type, 'strategy': strategy})\\n        if self.prevent_day_trading and order_type == 'sell' and await self.has_bought_today(symbol):\\n            logger.error('Day trading is not allowed. Cannot sell positions opened today.', extra={'symbol': symbol})\\n            return None\\n        try:\\n            response = self._place_option_order(symbol, quantity, order_type, price)\\n            logger.info('Order placed successfully', extra={'response': response})\\n            if not price:\\n                price = response.get('filled_price', None)\\n            trade = Trade(symbol=symbol, quantity=quantity, price=price, executed_price=price, order_type=order_type, status='filled', timestamp=datetime.now(), broker=self.broker_name, strategy=strategy, profit_loss=0, success='yes')\\n            if order_type == 'sell':\\n                profit_loss = self.db_manager.calculate_profit_loss(trade)\\n                logger.info('Profit/Loss calculated', extra={'profit_loss': profit_loss})\\n                trade.profit_loss = profit_loss\\n            async with self.Session() as session:\\n                session.add(trade)\\n                await session.commit()\\n            return response\\n        except Exception as e:\\n            logger.error('Failed to place order', extra={'error': str(e)})\\n            return None\\n\\n    async def place_order(self, symbol, quantity, order_type, strategy, price=None):\\n        logger.info('Placing order', extra={'symbol': symbol, 'quantity': quantity, 'order_type': order_type, 'strategy': strategy})\\n        if self.prevent_day_trading and order_type == 'sell' and await self.has_bought_today(symbol):\\n            logger.error('Day trading is not allowed. Cannot sell positions opened today.', extra={'symbol': symbol})\\n            return None\\n        try:\\n            response = self._place_order(symbol, quantity, order_type, price)\\n            logger.info('Order placed successfully', extra={'response': response})\\n            trade = Trade(symbol=symbol, quantity=quantity, price=response.get('filled_price', price), executed_price=response.get('filled_price', price), order_type=order_type, status='filled', timestamp=datetime.now(), broker=self.broker_name, strategy=strategy, profit_loss=0, success='yes')\\n            if order_type == 'sell':\\n                profit_loss = self.db_manager.calculate_profit_loss(trade)\\n                logger.info('Profit/Loss calculated', extra={'profit_loss': profit_loss})\\n                trade.profit_loss = profit_loss\\n            async with self.Session() as session:\\n                session.add(trade)\\n                await session.commit()\\n            return response\\n        except Exception as e:\\n            logger.error('Failed to place order', extra={'error': str(e)})\\n            return None\\n\\n    async def get_order_status(self, order_id):\\n        logger.info('Retrieving order status', extra={'order_id': order_id})\\n        try:\\n            order_status = self._get_order_status(order_id)\\n            async with self.Session() as session:\\n                trade = await session.execute(select(Trade).filter_by(id=order_id))\\n            trade = trade.scalars().first()\\n            if trade:\\n                await self.update_trade(session, trade.id, order_status)\\n            logger.info('Order status retrieved', extra={'order_status': order_status})\\n            return order_status\\n        except Exception as e:\\n            logger.error('Failed to get order status', extra={'error': str(e)})\\n            return None\\n\\n    async def cancel_order(self, order_id):\\n        logger.info('Cancelling order', extra={'order_id': order_id})\\n        try:\\n            cancel_status = self._cancel_order(order_id)\\n            async with self.Session() as session:\\n                trade = await session.execute(select(Trade).filter_by(id=order_id))\\n            trade = trade.scalars().first()\\n            if trade:\\n                await self.update_trade(session, trade.id, cancel_status)\\n            logger.info('Order cancelled successfully', extra={'cancel_status': cancel_status})\\n            return cancel_status\\n        except Exception as e:\\n            logger.error('Failed to cancel order', extra={'error': str(e)})\\n            return None\\n\\n    def position_exists(self, symbol):\\n        positions = self.get_positions()\\n        return symbol in positions\\n\\n    def get_options_chain(self, symbol, expiration_date):\\n        logger.info('Retrieving options chain', extra={'symbol': symbol, 'expiration_date': expiration_date})\\n        try:\\n            options_chain = self._get_options_chain(symbol, expiration_date)\\n            logger.info('Options chain retrieved', extra={'options_chain': options_chain})\\n            return options_chain\\n        except Exception as e:\\n            logger.error('Failed to retrieve options chain', extra={'error': str(e)})\\n            return None\\n\\n    async def update_trade(self, session, trade_id, order_info):\\n        try:\\n            trade = await session.execute(select(Trade).filter_by(id=trade_id))\\n            trade = trade.scalars().first()\\n            if not trade:\\n                logger.error('Trade not found for update', extra={'trade_id': trade_id})\\n                return\\n            executed_price = order_info.get('filled_price', trade.price)\\n            trade.executed_price = executed_price\\n            profit_loss = self.db_manager.calculate_profit_loss(trade)\\n            success = "success" if profit_loss > 0 else "failure"\\n            trade.executed_price = executed_price\\n            trade.success = success\\n            trade.profit_loss = profit_loss\\n            await session.commit()\\n            logger.info('Trade updated', extra={'trade': trade})\\n        except Exception as e:\\n            logger.error('Failed to update trade', extra={'error': str(e)})\\n