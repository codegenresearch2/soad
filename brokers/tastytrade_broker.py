import requests\"import time\"import json\"import re\"from decimal import Decimal\"from brokers.base_broker import BaseBroker\"from utils.logger import logger\"from utils.utils import extract_underlying_symbol, is_ticker, is_option, is_futures_symbol\n\nclass TastytradeBroker(BaseBroker):\n    def __init__(self, username, password, broker_name, engine=None, **kwargs):\n        super().__init__(username, password, broker_name, engine=engine, **kwargs)\n        self.username = username\n        self.password = password\n        self.broker_name = broker_name\n        logger.info('Initialized TastytradeBroker', extra={'broker_name': self.broker_name})\n        self.session = None\n        self.connect()\n\n    def connect(self):\n        logger.info('Connecting to Tastytrade API')\n        auth_data = {\n            'login': self.username,\n            'password': self.password,\n            'remember-me': True\n        }\n        response = requests.post('https://api.tastytrade.com/sessions', json=auth_data, headers={"Content-Type": "application/json"})\n        response.raise_for_status()\n        auth_response = response.json().get('data')\n        self.auth = auth_response['session-token']\n        self.headers = {"Authorization": self.auth}\n        self.session = Session(self.username, self.password)\n        logger.info('Connected to Tastytrade API')\n\n    def get_account_info(self):\n        logger.info('Retrieving account information')\n        try:\n            response = requests.get('https://api.tastytrade.com/customers/me/accounts', headers=self.headers)\n            response.raise_for_status()\n            account_info = response.json()\n            account_id = account_info['data']['items'][0]['account']['account-number']\n            self.account_id = account_id\n            balance_response = requests.get(f'https://api.tastytrade.com/accounts/{self.account_id}/balances', headers=self.headers)\n            balance_info = balance_response.json()\n            buying_power = balance_info['data']['equity-buying-power']\n            account_value = balance_info['data']['net-liquidating-value']\n            cash = balance_info['data']['cash-balance']\n            logger.info('Account info retrieved', extra={'account_id': self.account_id, 'buying_power': buying_power, 'value': account_value, 'cash': cash})\n            return {\n                'account_number': self.account_id,\n                'buying_power': float(buying_power),\n                'cash': float(cash),\n                'value': float(account_value)\n            }\n        except requests.RequestException as e:\n            logger.error('Failed to retrieve account information', extra={'error': str(e)})\n            raise\n\n    def get_positions(self):\n        logger.info('Retrieving positions')\n        try:\n            response = requests.get(f'https://api.tastytrade.com/accounts/{self.account_id}/positions', headers=self.headers)\n            response.raise_for_status()\n            positions_data = response.json()['data']['items']\n            positions = {self.process_symbol(p['symbol']): p for p in positions_data}\n            logger.info('Positions retrieved', extra={'positions': positions})\n            return positions\n        except requests.RequestException as e:\n            logger.error('Failed to retrieve positions', extra={'error': str(e)})\n            raise\n\n    def place_option_order(self, symbol, quantity, order_type, price=None):\n        logger.info('Placing option order', extra={'symbol': symbol, 'quantity': quantity, 'order_type': order_type, 'price': price})\n        try:\n            if ' ' not in symbol:\n                symbol = self.format_option_symbol(symbol)\n            if price is None:\n                price = self.get_current_price(symbol)\n            if order_type.lower() == 'buy':\n                action = OrderAction.BUY_TO_OPEN\n                price_effect = PriceEffect.DEBIT\n            elif order_type.lower() == 'sell':\n                action = OrderAction.SELL_TO_CLOSE\n                price_effect = PriceEffect.CREDIT\n            account = Account.get_account(self.session, self.account_id)\n            option = Option.get_option(self.session, symbol)\n            leg = option.build_leg(quantity, action)\n            order = NewOrder(time_in_force=OrderTimeInForce.DAY, order_type=OrderType.LIMIT, legs=[leg], price=Decimal(price), price_effect=price_effect)\n            response = account.place_order(self.session, order)\n            if response.errors:\n                logger.error('Order placement failed with errors', extra={'response': str(response)})\n            else:\n                if self.is_order_filled(response):\n                    logger.info('Order filled')\n                else:\n                    logger.info('Order likely still open')\n            return response\n        except Exception as e:\n            logger.error('Failed to place order', extra={'error': str(e)})\n            raise\n\n    def is_order_filled(self, order_response):\n        return order_response.order.status == OrderStatus.FILLED\n\n    def get_current_price(self, symbol):\n        logger.info('Getting current price for symbol', extra={'symbol': symbol})\n        try:\n            async with DXLinkStreamer(self.session) as streamer:\n                subs_list = [symbol]\n                await streamer.subscribe(EventType.QUOTE, subs_list)\n                quote = await streamer.get_event(EventType.QUOTE)\n                return round(float((quote.bidPrice + quote.askPrice) / 2), 2)\n        except Exception as e:\n            logger.error('Failed to get current price', extra={'error': str(e)})\n            raise\n\n    def get_bid_ask(self, symbol):\n        logger.info('Getting bid and ask for symbol', extra={'symbol': symbol})\n        try:\n            async with DXLinkStreamer(self.session) as streamer:\n                subs_list = [symbol]\n                await streamer.subscribe(EventType.QUOTE, subs_list)\n                quote = await streamer.get_event(EventType.QUOTE)\n                return {'bid': quote.bidPrice, 'ask': quote.askPrice}\n        except Exception as e:\n            logger.error('Failed to get bid and ask', extra={'error': str(e)})\n            raise\n\n    def get_options_chain(self, underlying_symbol):\n        logger.info('Fetching option chain for underlying symbol', extra={'underlying_symbol': underlying_symbol})\n        try:\n            option_chain = NestedOptionChain.get(self.session, underlying_symbol)\n            logger.info('Option chain retrieved', extra={'option_chain': option_chain})\n            return option_chain\n        except Exception as e:\n            logger.error('Failed to fetch option chain', extra={'error': str(e)})\n            raise\n\n    @staticmethod\n    def format_option_symbol(option_symbol):\n        match = re.match(r'^([A-Z]+)(\d{2})(\d{2})(\d{2})([CP])(\d{8})$', option_symbol)\n        if not match:\n            raise ValueError('Invalid option symbol format')\n        underlying = match.group(1)\n        rest_of_symbol = ''.join(match.groups()[1:])\n        formatted_symbol = f'{underlying:<6}{rest_of_symbol}'\n        return formatted_symbol\n