import requests\\nimport time\\\\nfrom brokers.base_broker import BaseBroker\\\\\nfrom utils.logger import logger  # Import the logger\\\\\nfrom utils.utils import extract_underlying_symbol\\\\\n\\nclass TradierBroker(BaseBroker):\\\\\n    def __init__(self, api_key, secret_key, engine, **kwargs):\\\\\n        super().__init__(api_key, secret_key, 'Tradier', engine=engine, **kwargs)\\\\\n        self.base_url = 'https://api.tradier.com/v1'\\\\\n        self.headers = {\"Authorization": f"Bearer {self.api_key}", \"Accept": "application/json"}\\\\\n        self.order_timeout = 1\\\\\n        self.auto_cancel_orders = True\\\\\n        logger.info('Initialized TradierBroker', extra={'base_url': self.base_url})\\\\\n        self._get_account_info()\\\\\n\\\\\n    def connect(self):\\\\\n        logger.info('Connecting to Tradier API')\\\\\n        # Placeholder for actual connection logic\\\\\n        pass\\\\\n\\\\\n    def _get_account_info(self):\\\\\n        logger.info('Retrieving account information')\\\\\n        try:\\\\\n            response = requests.get("https://api.tradier.com/v1/user/profile", headers=self.headers)\\\\\n            response.raise_for_status()\\\\\n            account_info = response.json()\\\\\n            account_id = account_info['profile']['account']['account_number']\\\\\n            self.account_id = account_id\\\\\n            logger.info('Account info retrieved', extra={'account_id': self.account_id})\\\\\n\\\\\n            url = f'{self.base_url}/accounts/{self.account_id}/balances'\\\\\n            response = requests.get(url, headers=self.headers)\\\\\n            response.raise_for_status()\\\\\n            account_info = response.json().get('balances')\\\\\n\\\\\n            if not account_info:\\\\\n                logger.error("Invalid account info response")\\\\\n\\\\\n            if account_info.get('cash'):\\\\\n                self.account_type = 'cash'\\\\\n                buying_power = account_info['cash']['cash_available']\\\\\n                account_value = account_info['total_equity']\\\\\n            elif account_info.get('margin'):\\\\\n                self.account_type = 'margin'\\\\\n                buying_power = account_info['margin']['stock_buying_power']\\\\\n                account_value = account_info['total_equity']\\\\\n            elif account_info.get('pdt'):\\\\\n                self.account_type = 'pdt'\\\\\n                buying_power = account_info['pdt']['stock_buying_power']\\\\\n                account_value = account_info['total_equity']\\\\\n            cash = account_info['total_cash']\\\\\n\\\\\n            logger.info('Account balances retrieved', extra={'account_type': self.account_type, 'buying_power': buying_power, 'value': account_value})\\\\\n            return {\"account_number": account_info['account_number'], \"account_type": self.account_type, \"buying_power": buying_power, \"cash": cash, \"value": account_value}\\\\\n        except requests.RequestException as e:\\\\\n            logger.error('Failed to retrieve account information', extra={'error': str(e)})\\\\\n\\\\\n    def get_positions(self):\\\\\n        logger.info('Retrieving positions')\\\\\n        url = f"{self.base_url}/accounts/{self.account_id}/positions"\\\\\n        try:\\\\\n            response = requests.get(url, headers=self.headers)\\\\\n            response.raise_for_status()\\\\\n            positions_data = response.json()['positions']['position']\\\\\n\\\\\n            if type(positions_data) != list:\\\\\n                positions_data = [positions_data]\\\\n            positions = {p['symbol']: p for p in positions_data} \\\\n            logger.info('Positions retrieved', extra={'positions': positions})\\\\\n            return positions\\\\\n        except requests.RequestException as e:\\\\\n            logger.error('Failed to retrieve positions', extra={'error': str(e)})\\\\\n\\\\\n    def _place_order(self, symbol, quantity, order_type, price=None):\\\\\n        logger.info('Placing order', extra={'symbol': symbol, 'quantity': quantity, 'order_type': order_type, 'price': price})\\\\\n        try:\\\\\n            if price is None:\\\\\n                quote_url = f"https://api.tradier.com/v1/markets/quotes?symbols={symbol}"\\\\\n                quote_response = requests.get(quote_url, headers=self.headers)\\\\\n                quote_response.raise_for_status()\\\\\n                quote = quote_response.json()['quotes']['quote']\\\\\n                bid = quote['bid']\\\\\n                ask = quote['ask']\\\\\n                price = round((bid + ask) / 2, 2)\\\\\n\\\\\n            order_data = {\"class": "equity", \"symbol": symbol, \"quantity": quantity, \"side": order_type, \"type": "limit", \"duration": "day", \"price": price}\\\\\n\\\\\n            response = requests.post(f"{self.base_url}/accounts/{self.account_id}/orders", data=order_data, headers=self.headers)\\\\\n            order_id = response.json()['order']['id']\\\\\n            logger.info('Order placed', extra={'order_id': order_id})\\\\\n            if self.auto_cancel_orders:\\\\\n                time.sleep(self.order_timeout)\\\\\n                order_status_url = f"{self.base_url}/accounts/{self.account_id}/orders/{order_id}"\\\\\n                status_response = requests.get(order_status_url, headers=self.headers)\\\\\n                status_response.raise_for_status()\\\\\n                order_status = status_response.json()['order']['status']\\\\\n\\\\\n                if order_status != 'filled':\\\\\\n                    try:\\\\\n                        cancel_url = f"{self.base_url}/accounts/{self.account_id}/orders/{order_id}/cancel"\\\\\n                        cancel_response = requests.put(cancel_url, headers=self.headers)\\\\\n                        cancel_response.raise_for_status()\\\\\n                        logger.info('Order cancelled', extra={'order_id': order_id})\\\\\n                    except requests.RequestException as e:\\\\\n                        logger.error('Failed to cancel order', extra={'order_id': order_id})\\\\\n\\\\\n            data = response.json() if response else {} \\\\n            if data.get('filled_price') is None:\\\\\n                data['filled_price'] = price\\\\\n            logger.info('Order execution complete', extra={'order_data': data})\\\\\n            return data\\\\\n        except requests.RequestException as e:\\\\\n            logger.error('Failed to place order', extra={'error': str(e)})\\\\\n\\\\\n    def _place_future_option_order(self, symbol, quantity, order_type, price=None):\\\\\n        logger.error('Future options not supported by Tradier', extra={'symbol': symbol})\\\\\n        raise NotImplementedError\\\\\n\\\\\n    def _place_option_order(self, symbol, quantity, order_type, price=None):\\\\\n        ticker = extract_underlying_symbol(symbol)\\\\\n        logger.info('Placing option order', extra={'symbol': symbol, 'quantity': quantity, 'order_type': order_type, 'price': price})\\\\\n        if order_type == 'buy':\\\\\n            order_type = 'buy_to_open'\\\\\n        elif order_type == 'sell':\\\\\n            order_type = 'sell_to_close'\\\\\n        try:\\\\\n            if price is None:\\\\\n                quote_url = f"https://api.tradier.com/v1/markets/quotes?symbols={symbol}"\\\\\n                quote_response = requests.get(quote_url, headers=self.headers)\\\\\n                quote_response.raise_for_status()\\\\\n                quote = quote_response.json()['quotes']['quote']\\\\\n                bid = quote['bid']\\\\\n                ask = quote['ask']\\\\\n                price = round((bid + ask) / 2, 2)\\\\\n\\\\\n            order_data = {\"class": "option", \"symbol": ticker, \"option_symbol": symbol, \"quantity": quantity, \"side": order_type, \"type": "limit", \"duration": "day", \"price": price}\\\\\n\\\\\n            response = requests.post(f"{self.base_url}/accounts/{self.account_id}/orders", data=order_data, headers=self.headers)\\\\\n            response.raise_for_status()\\\\\n\\\\\n            order_id = response.json()['order']['id']\\\\\n            logger.info('Order placed', extra={'order_id': order_id})\\\\\n            if self.auto_cancel_orders:\\\\\n                time.sleep(self.order_timeout)\\\\\n                order_status_url = f"{self.base_url}/accounts/{self.account_id}/orders/{order_id}"\\\\\n                status_response = requests.get(order_status_url, headers=self.headers)\\\\\n                status_response.raise_for_status()\\\\\n                order_status = status_response.json()['order']['status']\\\\\n\\\\\n                if order_status != 'filled':\\\\\\n                    try:\\\\\n                        cancel_url = f"{self.base_url}/accounts/{self.account_id}/orders/{order_id}/cancel"\\\\\n                        cancel_response = requests.put(cancel_url, headers=self.headers)\\\\\n                        cancel_response.raise_for_status()\\\\\n                        logger.info('Order cancelled', extra={'order_id': order_id})\\\\\n                    except requests.RequestException as e:\\\\\n                        logger.error('Failed to cancel order', extra={'order_id': order_id})\\\\\n\\\\\n            data = response.json()\\\\\n            if data.get('filled_price') is None:\\\\\n                data['filled_price'] = price\\\\\n            logger.info('Order execution complete', extra={'order_data': data})\\\\\n            return data\\\\\n        except requests.RequestException as e:\\\\\n            logger.error('Failed to place order', extra={'error': str(e)})\\\\\n\\\\\n    def _get_order_status(self, order_id):\\\\\n        logger.info('Retrieving order status', extra={'order_id': order_id})\\\\\n        try:\\\\\n            response = requests.get(f"{self.base_url}/accounts/orders/{order_id}", headers=self.headers)\\\\\n            response.raise_for_status()\\\\\n            order_status = response.json()\\\\\n            logger.info('Order status retrieved', extra={'order_status': order_status})\\\\\n            return order_status\\\\\n        except requests.RequestException as e:\\\\\n            logger.error('Failed to retrieve order status', extra={'error': str(e)})\\\\\n\\\\\n    def _cancel_order(self, order_id):\\\\\n        logger.info('Cancelling order', extra={'order_id': order_id})\\\\\n        try:\\\\\n            response = requests.delete(f"{self.base_url}/accounts/orders/{order_id}", headers=self.headers)\\\\\n            response.raise_for_status()\\\\\n            cancellation_response = response.json()\\\\\n            logger.info('Order cancelled successfully', extra={'cancellation_response': cancellation_response})\\\\\n            return cancellation_response\\\\\n        except requests.RequestException as e:\\\\\n            logger.error('Failed to cancel order', extra={'error': str(e)})\\\\\n\\\\\n    def _get_options_chain(self, symbol, expiration_date):\\\\\n        logger.info('Retrieving options chain', extra={'symbol': symbol, 'expiration_date': expiration_date})\\\\\n        try:\\\\\n            response = requests.get(f"{self.base_url}/markets/options/chains?symbol={symbol}&expiration={expiration_date}", headers=self.headers)\\\\\n            response.raise_for_status()\\\\\n            options_chain = response.json()\\\\\n            logger.info('Options chain retrieved', extra={'options_chain': options_chain})\\\\\n            return options_chain\\\\\n        except requests.RequestException as e:\\\\\n            logger.error('Failed to retrieve options chain', extra={'error': str(e)})\\\\\n\\\\\n    def get_current_price(self, symbol):\\\\\n        logger.info('Retrieving current price', extra={'symbol': symbol})\\\\\n        try:\\\\\n            response = requests.get(f"{self.base_url}/markets/quotes?symbols={symbol}", headers=self.headers)\\\\\n            response.raise_for_status()\\\\\n            last_price = response.json().get('quotes').get('quote').get('last')\\\\\n            logger.info('Current price retrieved', extra={'symbol': symbol, 'last_price': last_price})\\\\\n            return last_price\\\\\n        except requests.RequestException as e:\\\\\n            logger.error('Failed to retrieve current price', extra={'error': str(e)})\\\\\n\\\\\n    def get_bid_ask(self, symbol):\\\\\n        logger.info('Retrieving bid/ask', extra={'symbol': symbol})\\\\\n        try:\\\\\n            response = requests.get(f"{self.base_url}/markets/quotes?symbols={symbol}", headers=self.headers)\\\\\n            response.raise_for_status()\\\\\n            quote = response.json().get('quotes').get('quote')\\\\\n            bid = quote.get('bid')\\\\\n            ask = quote.get('ask')\\\\\n            logger.info('Bid/ask retrieved', extra={'symbol': symbol, 'bid': bid, 'ask': ask})\\\\\n            return { 'bid': bid, 'ask': ask }\\\\\n        except requests.RequestException as e:\\\\\n            logger.error('Failed to retrieve bid/ask', extra={'error': str(e)})\\\\\n